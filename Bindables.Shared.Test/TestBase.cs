using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using NUnit.Framework;

namespace Bindables.Test;

public abstract partial class TestBase<T> where T : PropertyGeneratorBase, new()
{
	private static readonly T Generator = new();
	
	public string AttributeNamespace => Generator.AttributeNamespace;
	public string PlatformNamespace => Generator.PlatformNamespace;
	public string DependencyPropertyAttributeName => Generator.DependencyPropertyAttributeName;
	public string AttachedPropertyAttributeName => Generator.AttachedPropertyAttributeName;
	public string BaseClassName => Generator.BaseClassName;
	public string DerivedFromBaseClassName => Generator.DerivedFromBaseClassName;
	public string GeneratorName => Generator.GeneratorName;
	public string GeneratorVersion => Generator.GeneratorVersion;
	public string DependencyPropertyName => Generator.DependencyPropertyName;
	public string DependencyPropertyKeyName => Generator.DependencyPropertyKeyName;
	public IReadOnlyList<string> PropertyChangedMethodParameterTypes => Generator.PropertyChangedMethodParameterTypes;
	public DiagnosticDescriptor DoesNotInheritFromBaseClassDiagnosticDescriptor => Generator.DoesNotInheritFromBaseClassDiagnosticDescriptor;

	public TestResult Generate(
		string? sourceCode = null,
		IReadOnlyList<AdditionalText>? additionalTexts = null,
		IReadOnlyList<SyntaxTree>? additionalSyntaxTrees = null)
	{
		List<MetadataReference> references = new();
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

		foreach (Assembly assembly in assemblies)
		{
			if (!assembly.IsDynamic)
			{
				references.Add(MetadataReference.CreateFromFile(assembly.Location));
			}
		}

		references.AddRange(GetAdditionalReferences());

		List<SyntaxTree> syntaxTrees = new();

		if (sourceCode != null)
		{
			syntaxTrees.Add(CSharpSyntaxTree.ParseText(sourceCode));
		}

		if (additionalSyntaxTrees != null)
		{
			syntaxTrees.AddRange(additionalSyntaxTrees);
		}

		CSharpCompilation compilation = CSharpCompilation.Create(
			"original",
			syntaxTrees,
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

		GeneratorDriver driver = CSharpGeneratorDriver.Create(new T());

		if (additionalTexts != null)
		{
			driver = driver.AddAdditionalTexts(ImmutableArray.CreateRange(additionalTexts));
		}

		driver.RunGeneratorsAndUpdateCompilation(
			compilation,
			out Compilation outputCompilation,
			out ImmutableArray<Diagnostic> diagnostics);

		List<Diagnostic> compilationErrors = outputCompilation
			.GetDiagnostics()
			.Where(x => x.Severity == DiagnosticSeverity.Error)
			.ToList();

		compilationErrors.AddRange(diagnostics);

		List<SyntaxTree> resultSyntaxTrees = outputCompilation.SyntaxTrees
			.Where(x => x.ToString().Contains("// Generated by Bindables"))
			.ToList();

		return new TestResult(resultSyntaxTrees, compilationErrors);
	}

	protected virtual IEnumerable<MetadataReference> GetAdditionalReferences()
	{
		return Enumerable.Empty<MetadataReference>();
	}

	protected void TestSourceCodeTemplate(
		string sourceCode,
		DiagnosticDescriptor? diagnosticDescriptor)
	{
		TestResult result = Generate(sourceCode);
		Diagnostic? error = result.Diagnostics.SingleOrDefault(x => x.Descriptor.Equals(diagnosticDescriptor));

		if (diagnosticDescriptor == null)
		{
			Assert.That(
				result.Diagnostics,
				Is.Empty,
				() => string.Join("\n", result.Diagnostics.Select(x => x.ToString())));

			Assert.That(error, Is.Null);
		}
		else
		{
			Assert.That(
				result.Diagnostics.Count,
				Is.EqualTo(1),
				() => string.Join("\n", result.Diagnostics.Select(x => x.ToString())));

			Assert.That(error, Is.Not.Null);
		}
	}

	protected void TestSourceCodeTemplate(
		string sourceCode,
		string expectedSourceCode)
	{
		TestResult result = Generate(sourceCode);
		CheckResult(result);

		
		Assert.That(result.SyntaxTrees, Has.Count.EqualTo(1));
		Assert.That(result.SyntaxTrees.Single().ToString().Trim(), Is.EqualTo(expectedSourceCode.Trim()));
	}

	public void CheckResult(TestResult result)
	{
		PrintSyntaxTrees(result);
		PrintWarningMessages(result);

		List<string> errorMessages = result.Diagnostics
			.Where(x => x.Severity >= DiagnosticSeverity.Error)
			.Select(x => x.ToString())
			.ToList();

		if (errorMessages.Any())
		{
			Assert.Fail(string.Join("\n", errorMessages));
		}
	}

	private void PrintSyntaxTrees(
		TestResult result,
		string? sourceCode = null,
		List<SyntaxTree>? additionalSyntaxTrees = null)
	{
		foreach (SyntaxTree syntaxTree in result.SyntaxTrees)
		{
			if (syntaxTree.ToString() == sourceCode)
			{
				continue;
			}

			if (additionalSyntaxTrees?.Contains(syntaxTree) == true)
			{
				continue;
			}

			Debug.WriteLine(syntaxTree);
		}
	}

	private void PrintWarningMessages(TestResult result)
	{
		List<string> warningMessages = result.Diagnostics
			.Where(x => x.Severity == DiagnosticSeverity.Warning)
			.Select(x => x.ToString())
			.ToList();

		foreach (string message in warningMessages)
		{
			Console.WriteLine(message);
		}
	}
}